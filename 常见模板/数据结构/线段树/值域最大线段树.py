class SegmentTree:
    """
    基于值域的线段树实现（区间最大值线段树）

    该线段树用于维护一个值域范围内的元素最大值，支持两种核心操作：
    1. 单点修改：更新某个位置的值
    2. 区间查询：查询指定区间内的最大值
    适用于需要高效处理动态值域范围最大值查询的场景
    """

    def __init__(self, u):
        """
        初始化线段树

        参数:
            u: 线段树覆盖的值域上限（即维护的范围为[1, u]）
        """
        self.u = u  # 值域上限
        # 线段树节点存储数组，大小为4*u（常规线段树空间分配方式，确保足够存储所有节点）
        self.tr = [0] * (4 * u)

    def modify(self, pos, val):
        """
        单点修改：更新指定位置pos的值为val

        参数:
            pos: 要修改的位置（需在[1, u]范围内）
            val: 要设置的新值
        """
        # 调用内部递归修改方法，根节点索引为1，初始覆盖区间为[1, u]
        self._modify(1, 1, self.u, val, pos)

    def _modify(self, o, l, r, val, pos):
        """
        内部递归实现的单点修改方法

        参数:
            o: 当前节点的索引（线段树中节点按完全二叉树编号）
            l: 当前节点覆盖的区间左端点
            r: 当前节点覆盖的区间右端点
            val: 要设置的新值
            pos: 要修改的位置
        """
        # 若当前节点是叶子节点（区间长度为1），直接更新节点值
        if l == r:
            self.tr[o] = val
            return
        # 计算区间中点，用于划分左右子树
        mid = (l + r) >> 1  # 等价于(l + r) // 2
        # 若修改位置在左子树区间内，递归修改左子树
        if pos <= mid:
            self._modify(o << 1, l, mid, val, pos)  # o << 1 等价于 2*o（左子树节点索引）
        # 否则递归修改右子树
        else:
            self._modify((o << 1) + 1, mid + 1, r, val, pos)  # (o << 1)+1 等价于 2*o+1（右子树节点索引）
        # 更新当前节点的值为左右子树的最大值（线段树的核心：父节点值由子节点聚合而来）
        self.tr[o] = max(self.tr[o << 1], self.tr[(o << 1) + 1])

    def query(self, L, R):
        """
        区间查询：查询[L, R]区间内的最大值

        参数:
            L: 查询区间的左端点
            R: 查询区间的右端点

        返回:
            [L, R]区间内的最大值
        """
        # 调用内部递归查询方法，根节点索引为1，初始覆盖区间为[1, u]
        return self._query(1, 1, self.u, L, R)

    def _query(self, o, l, r, L, R):
        """
        内部递归实现的区间查询方法

        参数:
            o: 当前节点的索引
            l: 当前节点覆盖的区间左端点
            r: 当前节点覆盖的区间右端点
            L: 查询区间的左端点
            R: 查询区间的右端点

        返回:
            当前节点覆盖区间与[L, R]交集部分的最大值
        """
        # 若当前节点覆盖区间完全在查询区间内，直接返回当前节点的值
        if L <= l and r <= R:
            return self.tr[o]
        # 初始化查询结果为0（根据场景可调整为负无穷等）
        ans = 0
        # 计算区间中点，划分左右子树
        mid = (l + r) >> 1
        # 若左子树与查询区间有交集，查询左子树并更新结果
        if mid >= L:
            ans = self._query(o << 1, l, mid, L, R)
        # 若右子树与查询区间有交集，查询右子树并取最大值
        if mid < R:
            ans = max(ans, self._query((o << 1) + 1, mid + 1, r, L, R))
        return ans