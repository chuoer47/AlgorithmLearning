"""
拓扑排序模板（基于Kahn算法）

算法功能：对有向图进行拓扑排序，返回顶点的线性序列，使得所有有向边从序列前部指向后部
适用场景：有向无环图（DAG），如任务调度、课程依赖关系等问题
核心优势：同时支持环检测（若图中存在环，返回空列表）

图的表示：邻接表（adjacency list）
- adj为列表，adj[u]存储u指向的所有顶点（即有向边u→v）
- 顶点编号从0开始，假设为连续整数
"""

from collections import deque


def topological_sort(adj: list) -> list:
    """
    对有向图进行拓扑排序（基于Kahn算法）

    算法思路：
    1. 计算所有顶点的入度（in-degree）
    2. 将入度为0的顶点加入队列（初始可执行节点）
    3. 每次从队列取出一个顶点u，加入结果序列
    4. 对u的所有邻接顶点v，将其入度减1；若v的入度变为0，加入队列
    5. 重复步骤3-4，直到队列为空
    6. 若结果序列长度等于顶点数，则为有效拓扑序；否则图中存在环

    参数:
        adj: 邻接表，adj[u] = [v1, v2, ...] 表示有向边u→v1, u→v2, ...

    返回:
        list: 拓扑排序后的顶点序列（按顺序排列）
              若图中存在环，返回空列表
    """
    n = len(adj)  # 顶点数量（假设顶点编号为0~n-1）

    # 1. 计算每个顶点的入度
    in_degree = [0] * n
    for u in range(n):
        for v in adj[u]:
            in_degree[v] += 1  # 每条边u→v，v的入度+1

    # 2. 初始化队列，加入所有入度为0的顶点
    q = deque()
    for u in range(n):
        if in_degree[u] == 0:
            q.append(u)

    # 3. 执行Kahn算法
    topo_order = []
    while q:
        u = q.popleft()  # 取出入度为0的顶点
        topo_order.append(u)  # 加入拓扑序列

        # 遍历u的所有邻接顶点，更新入度
        for v in adj[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:  # 入度变为0，加入队列
                q.append(v)

    # 4. 检查是否存在环（若序列长度不等于顶点数，说明有环）
    if len(topo_order) != n:
        return []  # 存在环，返回空列表
    return topo_order


# ------------------------------ 示例用法 ------------------------------
if __name__ == "__main__":
    # 示例1：正常DAG（课程依赖关系：0→1→3，0→2→3）
    adj1 = [
        [1, 2],  # 0指向1、2
        [3],  # 1指向3
        [3],  # 2指向3
        []  # 3无出边
    ]
    print("示例1拓扑序：", topological_sort(adj1))  # 可能输出：[0, 1, 2, 3] 或 [0, 2, 1, 3]

    # 示例2：存在环的图（0→1→2→0）
    adj2 = [
        [1],  # 0→1
        [2],  # 1→2
        [0],  # 2→0（形成环）
        []
    ]
    print("示例2拓扑序（有环）：", topological_sort(adj2))  # 输出：[]

    # 示例3：多个独立节点（无环，拓扑序任意）
    adj3 = [
        [],  # 0无出边
        [],  # 1无出边
        []  # 2无出边
    ]
    print("示例3拓扑序：", topological_sort(adj3))  # 可能输出：[0, 1, 2] 等任意排列
