def comb_mod10(n: int, m: int) -> int:
    """计算组合数 C(n, m) 模 10 的结果

    组合数 C(n, m) 表示从 n 个元素中选取 m 个元素的方案数，
    本函数通过数论方法高效计算该值对 10 取模的结果。

    算法思路：
    1. 利用 10 = 2 × 5 且 2 与 5 互质的性质，分别计算 C(n, m) mod 2 和 C(n, m) mod 5
    2. 再通过中国剩余定理（CRT）将两个结果组合，得到 C(n, m) mod 10 的结果

    参数:
        n: 总元素数量（非负整数）
        m: 要选取的元素数量（非负整数）

    返回:
        int: C(n, m) 对 10 取模的结果

    特殊情况:
        - 当 m < 0 或 m > n 时，组合数为 0，返回 0
        - 当 m = 0 时，组合数为 1，返回 1
    """
    # 组合数的基本边界条件处理
    if m < 0 or m > n:
        return 0
    if m == 0:
        return 1

    def mod2(n: int, m: int) -> int:
        """计算 C(n, m) 模 2 的结果

        基于 Lucas 定理的推论：C(n, m) 为奇数（mod 2 = 1）当且仅当
        m 的二进制表示是 n 的二进制表示的子集（即 (n & m) == m）

        参数:
            n: 总元素数量
            m: 选取的元素数量

        返回:
            int: C(n, m) mod 2 的结果（0 或 1）
        """
        # 二进制位运算判断：若 m 的所有置位在 n 中都置位，则返回 1（奇数）
        return 1 if (n & m) == m else 0

    # 使用Lucas定理计算 C(n, m) mod 5
    def mod5(n: int, m: int) -> int:
        """计算 C(n, m) 模 5 的结果

        基于 Lucas 定理：将 n 和 m 分解为 5 进制数，对每一位计算组合数后相乘取模

        Lucas定理核心：
        若 n = n_k*5^k + ... + n_0，m = m_k*5^k + ... + m_0
        则 C(n, m) ≡ ΠC(n_i, m_i) (mod 5)，若存在 m_i > n_i 则结果为 0

        参数:
            n: 总元素数量
            m: 选取的元素数量

        返回:
            int: C(n, m) mod 5 的结果（0-4）
        """
        # 预定义 5 以内组合数的模 5 结果表 C(a, b) mod 5
        # 行索引为 a，列索引为 b，对应 C(a, b) 的值
        mod5_table = [
            [1, 0, 0, 0, 0],  # a=0 时，只有 C(0,0)=1
            [1, 1, 0, 0, 0],  # a=1 时，C(1,0)=1, C(1,1)=1
            [1, 2, 1, 0, 0],  # a=2 时，C(2,0)=1, C(2,1)=2, C(2,2)=1
            [1, 3, 3, 1, 0],  # a=3 时的组合数
            [1, 4, 1, 4, 1],  # a=4 时的组合数
        ]
        result = 1
        # 按 5 进制位分解 n 和 m，逐位计算
        while n > 0 or m > 0:
            ni = n % 5  # 取 n 的当前 5 进制位
            mi = m % 5  # 取 m 的当前 5 进制位
            if mi > ni:  # 若某一位 m 的值大于 n，组合数为 0
                return 0
            # 累乘当前位的组合数结果，并模 5
            result = (result * mod5_table[ni][mi]) % 5
            # 移除已处理的 5 进制位
            n //= 5
            m //= 5
        return result

    # 分别计算模 2 和模 5 的结果
    a = mod2(n, m)  # C(n,m) mod 2
    b = mod5(n, m)  # C(n,m) mod 5

    # 应用中国剩余定理：找到 x 满足 x ≡ a mod 2 且 x ≡ b mod 5
    # 解为 x = (5 * ((a - b) % 2) + b) mod 10
    return (5 * ((a - b) % 2) + b) % 10
