"""使用埃拉托斯特尼筛法（Sieve of Eratosthenes）筛选质数的实现

核心功能：筛选出小于N的所有质数，存储在table列表中
算法思想：通过标记非质数的方式，高效找出范围内的所有质数
"""

# 筛选质数的范围上限：将找出所有小于N的质数（N=1000010）
N = 1000010
lst = [0] * N  # 标记数组：lst[i] = 0 表示i可能是质数，lst[i] = 1 表示i是合数（非质数）
table = []  # 存储筛选出的质数的列表


def prime():
    """使用埃拉托斯特尼筛法筛选出小于N的所有质数

    算法原理：
    1. 初始假设所有数都是质数（lst[i] = 0）
    2. 从最小的质数2开始，将其所有倍数标记为非质数（lst[倍数] = 1）
    3. 继续处理下一个未被标记的数（该数必为质数），重复步骤2
    4. 直到处理完所有小于N的数，未被标记的数即为质数

    过程说明：
    - 遍历范围：从2到N-1（因为1不是质数）
    - 标记逻辑：对于每个质数i，将i的所有倍数（2i, 3i, ...）标记为非质数
    - 结果存储：所有未被标记的数（lst[i] = 0）会被加入table列表

    注意：
    - 函数执行后，结果会存储在全局变量table中
    - 时间复杂度：O(n log log n)，空间复杂度：O(n)（由标记数组lst占用）
    """
    # 从2开始遍历（2是最小的质数）
    for i in range(2, N):
        # 若当前数未被标记（lst[i] = 0），则为质数
        if lst[i] == 0:
            # 将质数加入结果列表
            table.append(i)
            # 标记该质数的所有倍数为非质数
            tem = i  # 从i本身的2倍开始标记（i本身是质数，不标记）
            while tem < N:
                lst[tem] = 1  # 标记为非质数
                tem += i  # 移动到下一个倍数（i*2, i*3, ...）
