def prime_factors(n):
    """对正整数n进行质因数分解，返回其所有质因数及对应的幂次

    质因数分解是将一个正整数表示为若干质数的乘积形式，即 n = p1^e1 * p2^e2 * ... * pk^ek，
    其中p1, p2, ..., pk是质数，e1, e2, ..., ek是对应的幂次（正整数）。

    算法思路：
    1. 先单独处理唯一的偶质数2，避免后续循环处理偶数，提高效率
    2. 再处理所有奇数因子，从3开始，步长为2，直到sqrt(n)
    3. 若处理完毕后剩余的n仍大于2，则该n本身是一个质数

    参数:
        n: 待分解的正整数（n ≥ 2，若n < 2会返回空列表）

    返回:
        tuple: 包含两个列表的元组 (factor, power)
            - factor: 质因数列表，按从小到大排序
            - power: 对应质因数的幂次列表，与factor索引一一对应

    示例:
        >>> prime_factors(12)
        ([2, 3], [2, 1])  # 12 = 2^2 * 3^1
        >>> prime_factors(30)
        ([2, 3, 5], [1, 1, 1])  # 30 = 2^1 * 3^1 * 5^1
        >>> prime_factors(13)
        ([13], [1])  # 13是质数，分解为自身的1次幂
    """
    # 存储质因数的列表（如[2,3,5]）
    factor = []
    # 存储对应质因数的幂次（如[2,1,1]表示2^2、3^1、5^1）
    power = []

    # 单独处理2的幂次（唯一的偶质数，单独处理可减少后续循环次数）
    count = 0  # 记录2的幂次
    # 循环除以2，直到不能整除
    while n % 2 == 0:
        count += 1
        n = n // 2  # 整除后更新n的值
    # 若2是质因数（幂次>0），则加入列表
    if count > 0:
        factor.append(2)
        power.append(count)

    # 处理所有奇数因子（从3开始，步长为2，避免偶数）
    # 循环范围到sqrt(n)即可，因为若n有大于sqrt(n)的因子，必为最后剩余的质数
    for i in range(3, int(n ** 0.5) + 1, 2):
        count = 0  # 记录当前奇数i的幂次
        # 循环除以i，直到不能整除
        while n % i == 0:
            count += 1
            n = n // i  # 整除后更新n的值
        # 若i是质因数（幂次>0），则加入列表
        if count > 0:
            factor.append(i)
            power.append(count)

    # 若剩余的n大于2，说明n本身是一个质数（未被前面的因子分解）
    if n > 2:
        factor.append(n)
        power.append(1)  # 质数的幂次为1

    return factor, power
